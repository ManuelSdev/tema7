<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Counter</title>
</head>

<body>
  <kc-counter id="tony-counter" atributoA="100" value="77"></kc-counter>
</body>

</html>

<script>
  class KcCounter extends HTMLElement {
    static get observedAttributes() {
      return ['value', 'data-tgb'];
    }

    constructor() {

      super();

      // establecer el valor inicial
      this._value = 10;
    }

    set value(value) {
      this._value = value;
      this.valueElement.innerText = this._value;
    }

    get value() {
      return this._value;
    }

    connectedCallback() {
      this.innerHTML = `
        <button id="decrement">&minus;</button>
        <span id="value"></span>
        <button id="increment">&plus;</button>
      `;
      console.log('ssssssssssssssssss',this.valueElement)
      // obtengo la referencia al span del valor
      /*
      this.toni=document.querySelector('#tony-counter')
      //Esto pilla el value (qué es 100) de atributoA
      console.log(this.toni.attributes.atributoA.value)
      //el value de un atributo se retorna como string
      console.log(typeof(this.toni.attributes.atributoA.value))
      */
      this.valueElement = this.querySelector('#value');
      this.valueElement.innerText = this._value;

      // obtengo las instancias de los botones más y menos
      this.minusButton = this.querySelector('#decrement');
      this.plusButton = this.querySelector('#increment');

      // me suscribo a los eventos click
      this.minusButton.addEventListener('click', () => {
        this.value--;
        
      });
      this.plusButton.addEventListener('click', () => {
        this.value++;
      });
    }
    attributeChangedCallback(attrName, oldValue, newValue) {
      //el value de un atributo siempre empieza siendo null
      //por eso la primera siempre será null=>newValue
      console.log('hola',this.valueElement)
      console.log('attibuteChanged', attrName, oldValue, '=>', newValue);
      
      //Al inicio, this.valueElement.innerText = this._value....que es = 10, 
      //ya que en el constructor tenemos this._value=10
      //QUEREMOS pasar el 77 de value="77" en lugar del 10
      /*
      Esto que sigue, falla en el arranque porque this.value=...llama al set value,
      que contiene una referencia a this.valueElement...y this.valueElement
      Se establece en la connectedCallback, que se ejecuta despues
      de esta attributeChangedCallback

      this.value=parseInt(newValue,10)
      */
      this._value=parseInt(newValue,10)
      this.valueElement.innerText = this._value
    }

  }

  if (!customElements.get('kc-counter')) {
    customElements.define('kc-counter', KcCounter);
  }
</script>